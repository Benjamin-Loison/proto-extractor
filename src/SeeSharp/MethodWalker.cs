using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using System;
using System.Collections.Generic;
using System.Linq;

namespace protoextractor.extractor
{
    // Explore the code paths of a method and generate events for every possible
    // call generated by the method, including the following data:
    //      call ARGUMENTS;
    //      what CONDITIONS were necessary to reach the call instruction.
    // See CallInfo for passed information.
    // Emits similar events for non-local stores.
    public class MethodWalker
    {
        // Method that gets called when we call into another method.
        public Action<CallInfo> OnCall;
        // Method that gets called when we call into a setter (method).
        public Action<StoreInfo> OnStore;

        List<OpState> processing = new List<OpState>();

        HashSet<int> Explored = new HashSet<int>();
        // The method we inspect.
        MethodDefinition Method;

        public MethodWalker(MethodDefinition method)
        {
            Method = method;
            Method.Body.SimplifyMacros();
        }

        // Emulate the selected method and collect information about setting and retrieving values
        // on the object that contains the method. This information (see CallInfo/StoreInfo) can be used
        // to construct a generic program structure.
        public void Walk()
        {
            processing.Add(new OpState());

            while (processing.Count > 0)
            {
                /* SORT is NOT STABLE, so the following is not guaranteed to have the desired effect */
                // Sort by descending condition count
                // processing.Sort((a, b) => a.Conditions.Count - b.Conditions.Count);
                // Sort by descending offset number.. 
                // processing.Sort((a, b) => a.Offset - b.Offset);

                // OrderBy defers operations until the returned IEnumerable is queried.
                // Order in ascending order:
                //                  We want to operate the list as a stack;
                //                  We want to be able to pop the highest amount of conditions
                //                          AND highest amount of offset.
                var intermediate = processing.OrderBy(op => op.Conditions.Count);
                // Push the resulting order back to the processing list
                processing = intermediate.OrderBy(op => op.Offset).ToList();

                // We have extended the List interface with a Stack interface.
                var next = processing.Pop();

                // Annihilate the conditions from any branch joins
                while (processing.Any() && processing.Peek().Offset == next.Offset)
                {
                    var joinOp = processing.Pop();
                    // TODO
                    var deadConds = next.Conditions.Where(c => joinOp.Conditions.Any(c2 => c2.Offset == c.Offset)).ToList();
                    foreach (var c in deadConds)
                    {
                        next.Conditions.Remove(c);
                    }
                }
                Explore(next.Offset, next.Stack, next.Conditions);
            }
        }

        void Explore(int offset, List<object> stack, List<Condition> conditions)
        {
            // Fetch the targetted instruction from the method we are walking.
            var ins = Method.Body.Instructions.First(o => o.Offset == offset);
            // Do not go into an infinite loop of processing the same instructions
            if (Explored.Contains(ins.Offset)) return;
            Explored.Add(ins.Offset);

            // Emulate operations to build a stack (state) that respresents the original runtime execution.
            switch (ins.OpCode.Code)
            {
                case Code.Ldnull:
                    stack.Add("null");
                    break;
                case Code.Ldc_I4:
                case Code.Ldc_R4:
                case Code.Ldstr:
                    stack.Add(ins.Operand);
                    break;
                case Code.Ldloca:
                    stack.Add("&" + (ins.Operand as VariableReference).ToString());
                    break;
                case Code.Ldloc:
                    stack.Add((ins.Operand as VariableReference).ToString());
                    break;
                case Code.Ldfld:
                    var field = String.Format("{0}.{1}",
                        stack.Pop(), (ins.Operand as FieldReference).Name);
                    stack.Add(field);
                    break;
                case Code.Ldsfld:
                    stack.Add((ins.Operand as FieldReference).FullName);
                    break;
                case Code.Ldarg:
                    {
                        var idx = (ins.Operand as ParameterReference).Index;
                        if (idx == -1)
                        {
                            stack.Add("this");
                        }
                        else
                        {
                            stack.Add(String.Format("arg{0}", idx));
                        }
                    }
                    break;
                case Code.Ldelem_Ref:
                    {
                        var idx = stack.Pop();
                        var arr = stack.Pop();
                        stack.Add(String.Format("{0}[{1}]", arr, idx));
                    }
                    break;
                case Code.Ldftn:
                    stack.Add(String.Format("&({0})", ins.Operand));
                    break;
                case Code.Newobj:
                    {
                        var mr = ins.Operand as MethodReference;
                        var numParam = mr.Parameters.Count;
                        var stackIdx = stack.Count - numParam;
                        var args = stack.GetRange(stackIdx, numParam);
                        stack.RemoveRange(stackIdx, numParam);
                        var callString = String.Format("new {0}({1})",
                            mr.DeclaringType.Name, String.Join(", ", args));
                        stack.Add(callString);
                        if (OnCall == null) break;
                        args.Insert(0, "this");
                        OnCall(new CallInfo
                        {
                            Conditions = new List<Condition>(conditions),
                            Method = mr,
                            Arguments = args,
                            String = callString
                        });
                    }
                    break;
                case Code.Newarr:
                    stack.Add(String.Format("new {0}[{1}]",
                        (ins.Operand as TypeDefinition).FullName, stack.Pop()));
                    break;
                case Code.Brfalse:
                    {
                        var lhs = stack.Pop().ToString();
                        var src = ins.Offset;
                        var tgt = (ins.Operand as Instruction).Offset;
                        var cond = new Condition(src, lhs, Comparison.IsFalse);
                        var ncond = new Condition(src, lhs, Comparison.IsTrue);
                        Branch(tgt, stack, conditions, cond, ncond);
                    }
                    break;
                case Code.Brtrue:
                    {
                        var lhs = stack.Pop().ToString();
                        var src = ins.Offset;
                        var tgt = (ins.Operand as Instruction).Offset;
                        var cond = new Condition(src, lhs, Comparison.IsTrue);
                        var ncond = new Condition(src, lhs, Comparison.IsFalse);
                        Branch(tgt, stack, conditions, cond, ncond);
                    }
                    break;
                case Code.Beq:
                case Code.Bne_Un:
                case Code.Ble:
                case Code.Bge:
                case Code.Blt:
                case Code.Bgt:
                    {
                        var rhs = stack.Pop().ToString();
                        var lhs = stack.Pop().ToString();
                        var src = ins.Offset;
                        var tgt = (ins.Operand as Instruction).Offset;
                        Condition cond = null, ncond = null;
                        switch (ins.OpCode.Code)
                        {
                            case Code.Beq:
                                cond = new Condition(src, lhs, Comparison.Equal, rhs);
                                ncond = new Condition(src, lhs, Comparison.Inequal, rhs);
                                break;
                            case Code.Bne_Un:
                                cond = new Condition(src, lhs, Comparison.Inequal, rhs);
                                ncond = new Condition(src, lhs, Comparison.Equal, rhs);
                                break;
                            case Code.Ble:
                                // x <= y --> y >= x; !(x <= y) --> x > y
                                cond = new Condition(src, rhs, Comparison.GreaterThanEqual, lhs);
                                ncond = new Condition(src, lhs, Comparison.GreaterThan, rhs);
                                break;
                            case Code.Bge:
                                cond = new Condition(src, lhs, Comparison.GreaterThanEqual, rhs);
                                // !(x >= y) --> y > x
                                ncond = new Condition(src, rhs, Comparison.GreaterThan, lhs);
                                break;
                            case Code.Blt:
                                // x < y --> y > x; !(x < y) --> x >= y
                                cond = new Condition(src, rhs, Comparison.GreaterThan, lhs);
                                ncond = new Condition(src, lhs, Comparison.GreaterThanEqual, rhs);
                                break;
                            case Code.Bgt:
                                // !(x > y) --> y >= x
                                cond = new Condition(src, lhs, Comparison.GreaterThan, rhs);
                                ncond = new Condition(src, rhs, Comparison.GreaterThanEqual, lhs);
                                break;
                        }
                        Branch(tgt, stack, conditions, cond, ncond);
                    }
                    break;
                case Code.Br:
                    Explore((ins.Operand as Instruction).Offset, stack, conditions);
                    return;
                case Code.Stfld:
                    {
                        var arg = stack.Pop().ToString();
                        /*var obj = */
                        stack.Pop();
                        if (OnStore == null) break;
                        OnStore(new StoreInfo
                        {
                            Conditions = new List<Condition>(conditions),
                            Field = ins.Operand as FieldReference,
                            Argument = arg,
                        });
                    }
                    break;
                case Code.Stelem_Ref:
                    {
                        /*var val = */
                        stack.Pop();
                        /*var idx = */
                        stack.Pop();
                        /*var arr = */
                        stack.Pop();
                    }
                    break;
                case Code.Mul:
                    {
                        var rhs = stack.Pop().ToString();
                        var lhs = stack.Pop().ToString();
                        stack.Add(String.Format("{0} * {1}", lhs, rhs));
                    }
                    break;
                case Code.Call:
                case Code.Callvirt:
                    {
                        var mr = ins.Operand as MethodReference;
                        var args = new List<object>();
                        for (var i = 0; i < mr.Parameters.Count; i++)
                        {
                            args.Add(stack.Pop());
                        }
                        if (mr.HasThis)
                        {
                            args.Add(stack.Pop());
                        }
                        args.Reverse();
                        var callString = String.Format("{0}.{1}({2})",
                            mr.HasThis ? args.First().ToString() : mr.DeclaringType.Name,
                            mr.Name,
                            String.Join(", ",
                                mr.HasThis ? args.Skip(1) : args));
                        if (mr.ReturnType.FullName != "System.Void")
                        {
                            stack.Add(callString);
                        }
                        if (OnCall == null) break;
                        OnCall(new CallInfo
                        {
                            Conditions = new List<Condition>(conditions),
                            Method = mr,
                            Arguments = args,
                            String = callString
                        });
                    }
                    break;
            }

            if (ins.Next != null)
            {
                processing.Add(new OpState(ins.Next.Offset, stack, conditions));
            }
        }

        void Branch(int target, List<object> stack, List<Condition> conditions,
            Condition conditionTaken, Condition conditionNotTaken)
        {
            var newConds = new List<Condition>(conditions);
            newConds.Add(conditionTaken);

            conditions.Add(conditionNotTaken);

            processing.Add(new OpState(target, new List<object>(stack), newConds));
        }
    }

    public enum Comparison
    {
        Equal,
        Inequal,
        GreaterThan,
        GreaterThanEqual,
        IsTrue,
        IsFalse
    }

    public class Condition
    {
        public int Offset { get; set; }
        public string Lhs { get; set; }
        public string Rhs { get; set; }
        public Comparison Cmp { get; set; }

        public Condition(int offset, string lhs, Comparison cmp, string rhs = null)
        {
            Offset = offset;
            Lhs = lhs;
            Rhs = rhs;
            Cmp = cmp;
        }

        public override string ToString()
        {
            var cmpStr = "";
            switch (Cmp)
            {
                case Comparison.Equal: cmpStr = "=="; break;
                case Comparison.Inequal: cmpStr = "!="; break;
                case Comparison.GreaterThan: cmpStr = ">"; break;
                case Comparison.GreaterThanEqual: cmpStr = ">="; break;
                case Comparison.IsTrue: cmpStr = "== true"; break;
                case Comparison.IsFalse: cmpStr = "== false"; break;
            }
            return String.Format("{0} {1}{2}", Lhs, cmpStr,
                String.IsNullOrEmpty(Rhs) ? "" : " " + Rhs);
        }
    }

    // Meta information for execution of a certain operation.
    class OpState
    {
        // This class is used to evaluate a CERTAIN operation statement. This statement is a
        // part of the bytecode of the method that is inspected (see MethodWalker.Walk)

        // Index of the specific operation, starting from the beginning of the method body.
        public int Offset { get; set; }
        // Built up stack which is available to this operation.
        public List<object> Stack { get; set; }
        // Conditions that were evaluated in order to reach the operation.
        public List<Condition> Conditions { get; set; }

        public OpState()
        {
            Offset = 0;
            Stack = new List<object>();
            Conditions = new List<Condition>();
        }

        public OpState(int offset, List<object> stack, List<Condition> conditions)
        {
            Offset = offset;
            Stack = stack;
            Conditions = conditions;
        }
    }

    public class CallInfo
    {
        public List<Condition> Conditions { get; set; }
        public MethodReference Method { get; set; }
        public List<object> Arguments { get; set; }
        public string String { get; set; }
    }

    public class StoreInfo
    {
        public List<Condition> Conditions { get; set; }
        public FieldReference Field { get; set; }
        public string Argument { get; set; }
    }

    public static class DecompilerExtensions
    {
        /* 
         * List<T> is a more versatile stack than Stack<T>. 
         * We implement the Stack interface on List because normal cast is somehow not possible?!
         */

        // Pop behaviour is to remove and return the highest index item from the list.
        public static T Pop<T>(this List<T> stack)
        {
            // 0 - indexed
            var lastIdx = stack.Count - 1;
            var result = stack[lastIdx];
            stack.RemoveAt(lastIdx);
            return result;
        }
        
        // Peek is similar to Pop, but does not remove the item from the list.
        public static T Peek<T>(this List<T> stack)
        {
            // 0 - indexed
            var lastIdx = stack.Count - 1;
            var result = stack[lastIdx];
            return result;
        }

        // Push adds the item to the list after the highest indexed item.
        // The collection space is expanded if needed.
        public static void Push<T>(this List<T> stack, T item)
        {
            stack.Add(item);
        }

        // This function looks like it forces an underscore inbetween a lowercase letter and 
        // the next Uppercase letter..
        // eg; batlleNet => battle_net
        public static string ToLowerUnder(this string s)
        {
            var res = "";
            for (var i = 0; i < s.Length; i++)
            {
                // If the character is between ASCI 0x41 and 0x60, append and underscore to
                // the result
                if (s[i] >= 'A' && s[i] < 'a' && i != 0)
                {
                    res += "_";
                }
                // Append the lowercase string version of the character to the result.
                res += s[i].ToString().ToLower();
            }
            return res.TrimEnd('_');
        }

        //public static TypeName PackageName(this TypeReference type)
        //{
        //    var types = new List<string> { type.Name };
        //    while (type.DeclaringType != null)
        //    {
        //        type = type.DeclaringType;
        //        var tName = type.Name;
        //        if (tName == "Types") continue;
        //        types.Add(tName);
        //    }
        //    types.Reverse();
        //    return new TypeName(type.Namespace, String.Join(".", types));
        //}
    }
}
